/****************************************************************************
 * 
 * FILENAME
 *     Audio_Demo.c
 *
 * VERSION
 *     1.0 
 *
 * DESCRIPTION
 *
 *
 *
 *
 * DATA STRUCTURES
 *     None
 *
 * FUNCTIONS
 *
 *
 *     
 * HISTORY
 *     2004.08.04		Created by Yung-Chang Huang
 *
 *
 * REMARK
 *     None
 *
 **************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


#include "wbio.h"
#include "wblib.h"
#include "w99702_reg.h"
#include "W99702_Audio.h"
#include "wbfat.h"
#include "wb_fmi.h"
#include "resultcode.h"

//#define TEST_AC97
//#define TEST_I2S
//#define TEST_UDA1345TS

//#define TEST_W56964
#define TEST_ADDA
//#define TEST_MA3
//#define TEST_MA5
//#define TEST_MA5I
//#define TEST_MA5SI
//#define TEST_WM8753
//#define TEST_WM8978
//#define TEST_AK4569
//#define TEST_WM8751


UINT32 PCM_QUEUE_LEN		=	(256*1024);

//extern _MA3_COUNTER;

#define printf sysPrintf
#define sysPrintf(...)


static UINT8  *_pucPcmQueue = (UINT8 *)(0x180000 | 0x10000000);
//static UINT8  _pucPcmQueue [] = {
//	#include "8k.dat"
//};

volatile UINT32 _uPcmQHead, _uPcmQTail;
int isnotfinish = 1;
void record_to_file(INT choose);
#if 0

INT16 _sine_wave[48] = 
{
    0x10B0,0x2118,0x30EF,0x3FEF,0x4dd7,0x5a6b,0x6572,0x6ebd,0x7623,0x7b83,0x7ec7,
    0x7fdf,0x7ec7,0x7b83,0x7623,0x6ebd,0x6572,0x5a6b,0x4dd7,0x3fef,0x30ef,0x2118,
    0x10b0,0x0000,0xef50,0xdee8,0xcf11,0xc011,0xb229,0xa595,0x9a8e,0x9143,0x89dd,
    0x847d,0x8139,0x8021,0x8139,0x847d,0x89dd,0x9143,0x9a8e,0xa595,0xb229,0xc011,
    0xcf11,0xdee8,0xef50,0x0000
};

#endif
INT16 _WINX[512] = 
{
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 
	0x0002, 0x0002, 0x0002, 0x0002, 0x0003, 0x0003, 0x0003, 0x0004, 0x0004, 0x0005, 0x0005, 0x0006, 0x0007, 0x0008, 0x0008, 0x0009, 
	0x000A, 0x000C, 0x000D, 0x000E, 0x0010, 0x0011, 0x0013, 0x0015, 0x0017, 0x0019, 0x001C, 0x001E, 0x0021, 0x0024, 0x0027, 0x002B, 
	0x002F, 0x0033, 0x0037, 0x003C, 0x0041, 0x0047, 0x004D, 0x0053, 0x005A, 0x0061, 0x0069, 0x0071, 0x007A, 0x0083, 0x008D, 0x0098, 
	0x00A3, 0x00AF, 0x00BC, 0x00C9, 0x00D8, 0x00E7, 0x00F7, 0x0108, 0x011A, 0x012D, 0x0141, 0x0157, 0x016D, 0x0185, 0x019D, 0x01B8, 
	0x01D3, 0x01F0, 0x020F, 0x022F, 0x0250, 0x0274, 0x0299, 0x02BF, 0x02E8, 0x0312, 0x033F, 0x036D, 0x039E, 0x03D1, 0x0406, 0x043D, 
	0x0476, 0x04B3, 0x04F1, 0x0532, 0x0576, 0x05BD, 0x0606, 0x0652, 0x06A1, 0x06F3, 0x0749, 0x07A1, 0x07FD, 0x085B, 0x08BE, 0x0923, 
	0x098D, 0x09F9, 0x0A6A, 0x0ADE, 0x0B56, 0x0BD1, 0x0C51, 0x0CD5, 0x0D5C, 0x0DE8, 0x0E78, 0x0F0B, 0x0FA4, 0x1040, 0x10E1, 0x1186, 
	0x1230, 0x12DE, 0x1390, 0x1447, 0x1503, 0x15C3, 0x1687, 0x1751, 0x181F, 0x18F1, 0x19C8, 0x1AA4, 0x1B84, 0x1C69, 0x1D53, 0x1E41, 
	0x1F34, 0x202C, 0x2127, 0x2228, 0x232D, 0x2436, 0x2543, 0x2655, 0x276B, 0x2886, 0x29A4, 0x2AC6, 0x2BEC, 0x2D17, 0x2E44, 0x2F76, 
	0x30AB, 0x31E3, 0x331F, 0x345E, 0x35A0, 0x36E5, 0x382D, 0x3978, 0x3AC5, 0x3C14, 0x3D66, 0x3EB9, 0x400F, 0x4166, 0x42BF, 0x4419, 
	0x4574, 0x46D0, 0x482D, 0x498B, 0x4AE9, 0x4C47, 0x4DA5, 0x4F03, 0x5060, 0x51BD, 0x5319, 0x5474, 0x55CD, 0x5725, 0x587B, 0x59CF, 
	0x5B21, 0x5C70, 0x5DBD, 0x5F07, 0x604D, 0x6190, 0x62D0, 0x640B, 0x6543, 0x6676, 0x67A5, 0x68CF, 0x69F3, 0x6B13, 0x6C2D, 0x6D42, 
	0x6E50, 0x6F59, 0x705B, 0x7157, 0x724C, 0x733A, 0x7421, 0x7501, 0x75D9, 0x76AA, 0x7773, 0x7834, 0x78ED, 0x799E, 0x7A46, 0x7AE5, 
	0x7B7C, 0x7C0B, 0x7C90, 0x7D0C, 0x7D7F, 0x7DE9, 0x7E49, 0x7EA0, 0x7EEE, 0x7F32, 0x7F6C, 0x7F9D, 0x7FC4, 0x7FE1, 0x7FF5, 0x7FFF, 
	0x7FFF, 0x7FF5, 0x7FE1, 0x7FC4, 0x7F9D, 0x7F6C, 0x7F32, 0x7EEE, 0x7EA0, 0x7E49, 0x7DE9, 0x7D7F, 0x7D0C, 0x7C90, 0x7C0B, 0x7B7C, 
	0x7AE5, 0x7A46, 0x799E, 0x78ED, 0x7834, 0x7773, 0x76AA, 0x75D9, 0x7501, 0x7421, 0x733A, 0x724C, 0x7157, 0x705B, 0x6F59, 0x6E50, 
	0x6D42, 0x6C2D, 0x6B13, 0x69F3, 0x68CF, 0x67A5, 0x6676, 0x6543, 0x640B, 0x62D0, 0x6190, 0x604D, 0x5F07, 0x5DBD, 0x5C70, 0x5B21, 
	0x59CF, 0x587B, 0x5725, 0x55CD, 0x5474, 0x5319, 0x51BD, 0x5060, 0x4F03, 0x4DA5, 0x4C47, 0x4AE9, 0x498B, 0x482D, 0x46D0, 0x4574, 
	0x4419, 0x42BF, 0x4166, 0x400F, 0x3EB9, 0x3D66, 0x3C14, 0x3AC5, 0x3978, 0x382D, 0x36E5, 0x35A0, 0x345E, 0x331F, 0x31E3, 0x30AB, 
	0x2F76, 0x2E44, 0x2D17, 0x2BEC, 0x2AC6, 0x29A4, 0x2886, 0x276B, 0x2655, 0x2543, 0x2436, 0x232D, 0x2228, 0x2127, 0x202C, 0x1F34, 
	0x1E41, 0x1D53, 0x1C69, 0x1B84, 0x1AA4, 0x19C8, 0x18F1, 0x181F, 0x1751, 0x1687, 0x15C3, 0x1503, 0x1447, 0x1390, 0x12DE, 0x1230, 
	0x1186, 0x10E1, 0x1040, 0x0FA4, 0x0F0B, 0x0E78, 0x0DE8, 0x0D5C, 0x0CD5, 0x0C51, 0x0BD1, 0x0B56, 0x0ADE, 0x0A6A, 0x09F9, 0x098D, 
	0x0923, 0x08BE, 0x085B, 0x07FD, 0x07A1, 0x0749, 0x06F3, 0x06A1, 0x0652, 0x0606, 0x05BD, 0x0576, 0x0532, 0x04F1, 0x04B3, 0x0476, 
	0x043D, 0x0406, 0x03D1, 0x039E, 0x036D, 0x033F, 0x0312, 0x02E8, 0x02BF, 0x0299, 0x0274, 0x0250, 0x022F, 0x020F, 0x01F0, 0x01D3, 
	0x01B8, 0x019D, 0x0185, 0x016D, 0x0157, 0x0141, 0x012D, 0x011A, 0x0108, 0x00F7, 0x00E7, 0x00D8, 0x00C9, 0x00BC, 0x00AF, 0x00A3, 
	0x0098, 0x008D, 0x0083, 0x007A, 0x0071, 0x0069, 0x0061, 0x005A, 0x0053, 0x004D, 0x0047, 0x0041, 0x003C, 0x0037, 0x0033, 0x002F, 
	0x002B, 0x0027, 0x0024, 0x0021, 0x001E, 0x001C, 0x0019, 0x0017, 0x0015, 0x0013, 0x0011, 0x0010, 0x000E, 0x000D, 0x000C, 0x000A, 
	0x0009, 0x0008, 0x0008, 0x0007, 0x0006, 0x0005, 0x0005, 0x0004, 0x0004, 0x0003, 0x0003, 0x0003, 0x0002, 0x0002, 0x0002, 0x0002, 
	0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 

};
	
	

INT  play_callback(UINT8 *pucBuff, UINT32 uDataLen)
{
	INT		nLen;
	INT		idx;
//sysInvalidCache();
#if 0	/* force play sine wave */
	for (idx = 0; idx < 50; idx++)
	{
		memcpy(pucBuff, _sine_wave, 192);
		pucBuff += 192;
	}
	return;
#endif

#ifdef TEST_MA3
	for (idx = 0; idx < uDataLen; idx++)
	{
		pucBuff[idx] = _pucPcmQueue[_uPcmQHead+1];   /* left channel */
		pucBuff[idx+uDataLen] = _pucPcmQueue[_uPcmQHead+3];   /* right channel */
		_uPcmQHead += 4;
	}
	_uPcmQHead %= PCM_QUEUE_LEN;
	return 0;
#endif

#ifdef TEST_MA5
	for (idx = 0; idx < uDataLen; idx+=2)
	{
		pucBuff[idx] = _pucPcmQueue[_uPcmQHead];
		pucBuff[idx+1] = _pucPcmQueue[_uPcmQHead+1];
		pucBuff[uDataLen+idx] = _pucPcmQueue[_uPcmQHead+2];
		pucBuff[uDataLen+idx+1] = _pucPcmQueue[_uPcmQHead+3];
		_uPcmQHead = (_uPcmQHead+4) % PCM_QUEUE_LEN;
	}
	return 0;
#endif
	nLen = PCM_QUEUE_LEN - _uPcmQHead;
	if (nLen==uDataLen)
			isnotfinish=0;
	if (nLen >= uDataLen)
	{
		memcpy(pucBuff, &_pucPcmQueue[_uPcmQHead], uDataLen);
		_uPcmQHead = (_uPcmQHead + uDataLen) % PCM_QUEUE_LEN;
	}
	else
	{
		memcpy(pucBuff, &_pucPcmQueue[_uPcmQHead], nLen);
		memcpy(&pucBuff[nLen], _pucPcmQueue, uDataLen - nLen);
		_uPcmQHead = uDataLen - nLen;
		isnotfinish=0;
	}

	
	return 0;
}


INT  record_callback(UINT8 *pucBuff, UINT32 uDataLen)
{
	INT		nLen;

	nLen = PCM_QUEUE_LEN - _uPcmQTail;
	if (nLen >= uDataLen)
	{
		memcpy(&_pucPcmQueue[_uPcmQTail], pucBuff, uDataLen);
		_uPcmQTail = (_uPcmQTail + uDataLen) % PCM_QUEUE_LEN;
	}
	else
	{
		memcpy(&_pucPcmQueue[_uPcmQTail], pucBuff, nLen);
		memcpy(_pucPcmQueue, &pucBuff[nLen], uDataLen - nLen);
		_uPcmQTail = uDataLen - nLen;
	}
	return 0;
}




void  audio_loopback_demo(INT choose,INT ch)
{
	_uPcmQHead = _uPcmQTail = 0;

	audioSetRecordVolume(0x8,0x8);
	audioStartRecord(record_callback, choose, ch);
	
	//printf("Start record...\n");
	while(_uPcmQTail < 512*2);
	audioStopRecord();
}	


#define MAXN 512


int main()
{

	int N = MAXN; // maximum N is 512 
	int logN = 9;
	int i;
	int xr[MAXN], xi[MAXN];
	float x[MAXN];
	float SSum,NSum;
	float	SNR;


	sysSetGlobalInterrupt(DISABLE_ALL_INTERRUPTS); /* write 0xFFFFFFFF to AIC_MDCR */
	//sysConfiguration();
	//sysEnableCache(CACHE_WRITE_BACK);
	outpw(REG_CLKSEL,  0x104);      /* system clock source is from external clock */  
	outpw(REG_CLKDIV0, 0x01104001); /* PCLK/2 */
  	outpw(REG_CLKDIV1, 0x00015555); /* HCLK2/2 */  
	outpw(REG_CLKCON,  0x1B003090);
	outpw(REG_CLKSEL,  0x110);
	


#ifdef TEST_ADDA
#if 1 //22.579Mhz
		outpw(REG_APLLCON, 0x642d);
		outpw(REG_CLKDIV0, (inpw(REG_CLKDIV0) & 0xFF0FFFFF));

#else
		outpw(REG_APLLCON, 0x6529);//24.576Mhz
		outpw(REG_CLKDIV0, (inpw(REG_CLKDIV0) & 0xFF0FFFFF) | 0x100000);
#endif
#endif

	/* 
	 * CLK select: SYSTEM_S from UPLL, AUDIO_S from APLL 
	 * SENSOR_S and VIDEO_S from crystal in 
	 */

#ifdef TEST_ADDA
	audioEnable(AU_DEV_ADC, AU_DEV_ADC);
#endif	

	audioSetRecBuff(0x100c0000, 256);

	//sysSetTimerReferenceClock (TIMER1, 12000000);
	//sysStartTimer(TIMER1, 100, PERIODIC_MODE);
    
  	outpw(REG_GPIO_OE, inpw(REG_GPIO_OE) & ~(3<<1) & ~(0x3F<<14));	/* GPIO 1~2:status, 14~19: value*/
	outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) & ~(0x3<<1));//proceeding
	audio_loopback_demo(AU_SAMPLE_RATE_48000,1);

	fftsg_init();

	for(i=0;i<N;i++)
	{
		//xr[i] = (int)(_sine_wave[i%48]*_WINX[i])>>7;
		xr[i] = (int)(*((short *)(_pucPcmQueue + i*2))*_WINX[i])>>7;
		//printf("%d\n",xr[i]);
        xi[i] = 0;
	}

	fftsg(xr, xi, logN);
			
	for(i=0;i<(20*1000/(48*1000/N));i++)
	{
		
		xr[i] = (int)((((__int64)xr[i]*(__int64)xr[i])+((__int64)xi[i]*(__int64)xi[i])) >> 28);
		x[i] = xr[i]/64.0/16.0;
		//printf("%f\n",x[i]);
	}


	for(i=0;i<(20*1000/(48*1000/N));i++)
	{
		if ( (i>=11 - 8) && (i<=11+8)){
			SSum = SSum + x[i];
		}
		else
		{
			NSum = NSum + x[i];
		}
	}
	
	if (NSum == 0)
	{
		NSum = 0.0001;
	}
	if (SSum == 0)
	{
		SSum = 0.0001;
	}

	
	SNR = (float) (10*log10(SSum/213) - 10*log10(NSum/196)) + 60;
	
	if (SNR >= 50)
	{
		outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) & ~(0x3<<1));
	  outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) | (0x1<<1));//pass
	  printf("pass\n");
	}else if (SNR < 50)
	{
		outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) & ~(0x3<<1));
	  outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) | (0x2<<1));//fail
	  printf("fail\n");
	}

	//SNR = (float) (10*log10(_1kVal) - 10*log10(SSum));
	outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) & ~0x3f8);
	outpw(REG_GPIO_DAT, inpw(REG_GPIO_DAT) | (((int)SNR & 0xff)>>2) << 14);
	printf("SNR = %f\n",SNR);
	fftsg_end();

//	audio_loopback_demo(AU_SAMPLE_RATE_44100,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_32000,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_24000,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_22050,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_16000,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_11025,1);
//	audio_loopback_demo(AU_SAMPLE_RATE_8000,1);

//   record_to_file(AU_SAMPLE_RATE_24000);
}


