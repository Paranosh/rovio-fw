/** @file wlan_cmdresp.c
  * @brief This file contains the handling of command
  * responses as well as events generated by firmware.
  * 
  *  Copyright ?Marvell International Ltd. and/or its affiliates, 2003-2006
  */
/********************************************************
Change log:
	10/10/05: Add Doxygen format comments
	11/11/05: Add support for WMM Status change event
	12/13/05: Add Proprietary periodic sleep support
	12/23/05: Fix bug in adhoc start where the current index was
	          not properly being assigned before it was used.
	01/05/06: Add kernel 2.6.x support	
	01/11/06: Conditionalize new scan/join structures.
	          Update assoc response handling; entire IEEE response returned
	04/06/06: Add TSPEC, queue metrics, and MSDU expiry support
	04/10/06: Add hostcmd generic API
	04/18/06: Remove old Subscrive Event and add new Subscribe Event
		  implementation through generic hostcmd API
	05/04/06: Add IBSS coalescing related new hostcmd response handling
	05/08/06: Remove Adapter->PermanentAddr memcpy
	06/08/06: Remove function HandleMICFailureEvent()
********************************************************/

#include	"include.h"

/********************************************************
		Local Variables
********************************************************/

/********************************************************
		Global Variables
********************************************************/

extern int ethernetRunning;

/********************************************************
		Local Functions
********************************************************/

/** 
 *  @brief This function handles disconnect event. it
 *  reports disconnect to upper layer, clean tx/rx packets,
 *  reset link state etc.
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @return 	   n/a
 */
void
MacEventDisconnected(wlan_private *priv)
{
    wlan_adapter *Adapter = priv->adapter;
    union iwreq_data wrqu;

    ENTER();

    if (Adapter->MediaConnectStatus != WlanMediaStateConnected)
        return;

    diag_printf("Handles disconnect event.\n");
    ethernetRunning = 0;//clyu

    memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
    wrqu.ap_addr.sa_family = ARPHRD_ETHER;

    /* 
     * Cisco AP sends EAP failure and de-auth in less than 0.5 ms.
     * It causes problem in the Supplicant
     */

    //os_sched_timeout(1000);
    cyg_thread_delay(100);
    wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);

    /* Free Tx and Rx packets */
    //os_free_tx_packet(priv);
    //wlan_send_rxskbQ(priv);

    /* report disconnect to upper layer */
    //os_stop_queue(priv);
    //os_carrier_off(priv);

    /* reset SNR/NF/RSSI values */
    memset(Adapter->SNR, 0x00, sizeof(Adapter->SNR));
    memset(Adapter->NF, 0x00, sizeof(Adapter->NF));
    memset(Adapter->RSSI, 0x00, sizeof(Adapter->RSSI));
    memset(Adapter->rawSNR, 0x00, sizeof(Adapter->rawSNR));
    memset(Adapter->rawNF, 0x00, sizeof(Adapter->rawNF));
    Adapter->nextSNRNF = 0;
    Adapter->numSNRNF = 0;
    Adapter->RxPDRate = 0;
    diag_printf("Current SSID=%s, Ssid Length=%u\n",
           Adapter->CurBssParams.ssid.Ssid,
           Adapter->CurBssParams.ssid.SsidLength);
    diag_printf("Previous SSID=%s, Ssid Length=%u\n",
           Adapter->PreviousSSID.Ssid, Adapter->PreviousSSID.SsidLength);

    /* reset internal flags */
    Adapter->AdHocCreated = FALSE;

    if (Adapter->wmm.enabled) {
        Adapter->wmm.enabled = FALSE;
        wmm_cleanup_queues(priv);
    }
    cleanup_txqueues(priv);

    Adapter->SecInfo.WPAEnabled = FALSE;
    Adapter->SecInfo.WPA2Enabled = FALSE;
    Adapter->Wpa_ie_len = 0;
    Adapter->SecInfo.EncryptionMode = CIPHER_NONE;

    Adapter->MediaConnectStatus = WlanMediaStateDisconnected;
    Adapter->LinkSpeed = MRVDRV_LINK_SPEED_1mbps;

    /* 
     * memorize the previous SSID and BSSID
     * it could be used for re-assoc
     */
    memcpy((void *)&Adapter->PreviousSSID,
           (void *)&Adapter->CurBssParams.ssid, sizeof(WLAN_802_11_SSID));
    memcpy(Adapter->PreviousBSSID,
           Adapter->CurBssParams.bssid, MRVDRV_ETH_ADDR_LEN);

    /* need to erase the current SSID and BSSID info */
    Adapter->pAttemptedBSSDesc = 0;
    memset(&Adapter->CurBssParams, 0, sizeof(Adapter->CurBssParams));

    if (Adapter->PSState != PS_STATE_FULL_POWER) {
        /* make firmware to exit PS mode */
        diag_printf("Disconnected, so exit PS mode.\n");
        PSWakeup(priv, 0);
    }

    LEAVE();
}

/** 
 *  @brief This function handles link lost, deauth and
 *  disassoc events.
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @return 	   n/a
 */
static void
HandleDisconnectEvent(wlan_private *priv)
{
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    if (Adapter->MediaConnectStatus == WlanMediaStateConnected) {
        MacEventDisconnected(priv);
#ifdef REASSOCIATION
        if (Adapter->Reassoc_on == TRUE) {
            diag_printf("RE-ASSOC: trigger the timer\n");
            Adapter->TimerIsSet = TRUE;
            //ModTimer(&Adapter->MrvDrvTimer, 0);
           	cyg_alarm_initialize(reassociation_alarm_handle, cyg_current_time() + 1, 0);
            //MrvDrvTimerFunction(reassociation_alarm_handle, (cyg_addrword_t)priv);

        }
#endif /* REASSOCIATION */
    }
}

/** 
 *  @brief This function handles the command response of reg_access
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param type	   the type of reg access (MAC, BBP or RF)
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_reg_access(wlan_private * priv, cyg_uint16 type, HostCmd_DS_COMMAND * resp)
{
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    switch (type) {
    case HostCmd_RET_MAC_REG_ACCESS:
        {
            HostCmd_DS_MAC_REG_ACCESS *reg;

            reg = (PHostCmd_DS_MAC_REG_ACCESS) & resp->params.macreg;

            Adapter->OffsetValue.offset = reg->Offset;
            Adapter->OffsetValue.value = reg->Value;
            break;
        }

    case HostCmd_RET_BBP_REG_ACCESS:
        {
            HostCmd_DS_BBP_REG_ACCESS *reg;
            reg = (PHostCmd_DS_BBP_REG_ACCESS) & resp->params.bbpreg;

            Adapter->OffsetValue.offset = reg->Offset;
            Adapter->OffsetValue.value = reg->Value;
            break;
        }

    case HostCmd_RET_RF_REG_ACCESS:
        {
            HostCmd_DS_RF_REG_ACCESS *reg;
            reg = (PHostCmd_DS_RF_REG_ACCESS) & resp->params.rfreg;

            Adapter->OffsetValue.offset = reg->Offset;
            Adapter->OffsetValue.value = reg->Value;
            break;
        }

    default:
        LEAVE();
        return WLAN_STATUS_FAILURE;
    }

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of get_hw_spec
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_get_hw_spec(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    cyg_uint32 i;
    HostCmd_DS_GET_HW_SPEC *hwspec = &resp->params.hwspec;
    wlan_adapter *Adapter = priv->adapter;
    w99702_priv_t *w702priv = priv->priv;
    int ret = WLAN_STATUS_SUCCESS;

    ENTER();

    Adapter->fwCapInfo = wlan_le32_to_cpu(hwspec->fwCapInfo);

    Adapter->FWReleaseNumber = hwspec->FWReleaseNumber;

    diag_printf("GET_HW_SPEC: FWReleaseVersion- 0x%X\n",
           Adapter->FWReleaseNumber);
    diag_printf("GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
           hwspec->PermanentAddr[0], hwspec->PermanentAddr[1],
           hwspec->PermanentAddr[2], hwspec->PermanentAddr[3],
           hwspec->PermanentAddr[4], hwspec->PermanentAddr[5]);
    diag_printf("GET_HW_SPEC: HWIfVersion=0x%X  Version=0x%X\n",
           hwspec->HWIfVersion, hwspec->Version);

    Adapter->RegionCode = wlan_le16_to_cpu(hwspec->RegionCode);

    for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
        /* use the region code to search for the index */
        if (Adapter->RegionCode == RegionCodeToIndex[i]) {
            Adapter->RegionTableIndex = (cyg_uint16) i;
            break;
        }
    }

    /* if it's unidentified region code, use the default (USA) */
    if (i >= MRVDRV_MAX_REGION_CODE) {
        Adapter->RegionCode = 0x10;
        Adapter->RegionTableIndex = 0;
        diag_printf("unidentified region code, use the default (USA)\n");
    }

    if (Adapter->CurrentAddr[0] == 0xff) {
        memmove(Adapter->CurrentAddr, (void *)hwspec->PermanentAddr,
                MRVDRV_ETH_ADDR_LEN);
     	memmove(w702priv->mac_address, (void *)hwspec->PermanentAddr, MRVDRV_ETH_ADDR_LEN);
        
        diag_printf("Adapter->CurrentAddr: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
           Adapter->CurrentAddr[0], Adapter->CurrentAddr[1],
           Adapter->CurrentAddr[2], Adapter->CurrentAddr[3],
           Adapter->CurrentAddr[4], Adapter->CurrentAddr[5]);
        
    }
//    memcpy(priv->wlan_dev.netdev->dev_addr, Adapter->CurrentAddr, ETH_ALEN);

    if (wlan_set_regiontable(priv, Adapter->RegionCode, 0)) {
        ret = WLAN_STATUS_FAILURE;
        goto done;
    }

    if (wlan_set_universaltable(priv, 0)) {
        ret = WLAN_STATUS_FAILURE;
        goto done;
    }

  done:
    LEAVE();
    return ret;
}

/** 
 *  @brief This function handles the command response of host_sleep_cfg
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_host_sleep_cfg(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    wlan_adapter *Adapter = priv->adapter;
    HostCmd_DS_802_11_HOST_SLEEP_CFG *hscfg = &resp->params.hostsleepcfg;
    int ret = WLAN_STATUS_SUCCESS;

    ENTER();
	diag_printf("host sleep cfg %d, %d\n", hscfg->conditions, hscfg->gap);
    if (hscfg->conditions != HOST_SLEEP_CFG_CANCEL) {
        Adapter->bHostSleepConfigured = TRUE;
        Adapter->HSCfg_Gap = hscfg->gap;
        if (Adapter->PSState == PS_STATE_FULL_POWER) { //JONO
            ret = PrepareAndSendCommand(priv,
                                        HostCmd_CMD_802_11_HOST_SLEEP_ACTIVATE,
                                        0, 0, 0, NULL);
        } //JONO
    } else {
        Adapter->bHostSleepConfigured = FALSE;
        Adapter->HSCfg_Gap = 0;
    }

    LEAVE();
    return ret;
}

/** 
 *  @brief This function handles the command response of fw_wakeup_method
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_fw_wakeup_method(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    wlan_adapter *Adapter = priv->adapter;
    HostCmd_DS_802_11_FW_WAKEUP_METHOD *fwwm = &resp->params.fwwakeupmethod;
    cyg_uint16 action;

    ENTER();

    action = wlan_le16_to_cpu(fwwm->Action);

    switch (action) {
    case HostCmd_ACT_GET:
    case HostCmd_ACT_SET:
        Adapter->fwWakeupMethod = wlan_le16_to_cpu(fwwm->Method);
        break;
    default:
        break;
    }

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of sleep_params
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_sleep_params(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_SLEEP_PARAMS *sp = &resp->params.sleep_params;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    diag_printf("error=%x offset=%x stabletime=%x calcontrol=%x\n"
           " extsleepclk=%x\n", sp->Error, sp->Offset,
           sp->StableTime, sp->CalControl, sp->ExternalSleepClk);
    Adapter->sp.sp_error = wlan_le16_to_cpu(sp->Error);
    Adapter->sp.sp_offset = wlan_le16_to_cpu(sp->Offset);
    Adapter->sp.sp_stabletime = wlan_le16_to_cpu(sp->StableTime);
    Adapter->sp.sp_calcontrol = wlan_le16_to_cpu(sp->CalControl);
    Adapter->sp.sp_extsleepclk = wlan_le16_to_cpu(sp->ExternalSleepClk);
    Adapter->sp.sp_reserved = wlan_le16_to_cpu(sp->Reserved);

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of sleep_params
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_sleep_period(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_SLEEP_PERIOD *sp_period = &resp->params.ps_sleeppd;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    Adapter->sleep_period.period = wlan_le16_to_cpu(sp_period->Period);

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of bca_timeshare
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_bca_timeshare(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_BCA_TIMESHARE *bca_ts = &resp->params.bca_timeshare;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    diag_printf("TrafficType=%x TimeShareInterva=%x BTTime=%x\n",
           bca_ts->TrafficType, bca_ts->TimeShareInterval, bca_ts->BTTime);

    Adapter->bca_ts.TrafficType = wlan_le16_to_cpu(bca_ts->TrafficType);
    Adapter->bca_ts.TimeShareInterval =
        wlan_le32_to_cpu(bca_ts->TimeShareInterval);
    Adapter->bca_ts.BTTime = wlan_le32_to_cpu(bca_ts->BTTime);

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of mac_control
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_mac_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of set_wep
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_set_wep(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of reset
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_reset(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    ENTER();
    diag_printf("HWAC - Reset command successful\n");

    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of statistics
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_stat(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_GET_STAT *p11Stat = &resp->params.gstat;
    wlan_adapter *Adapter = priv->adapter;

    /* TODO Convert it to Big endian befor copy */
    memcpy((void *)&Adapter->wlan802_11Stat,
           (void *)p11Stat, sizeof(HostCmd_DS_802_11_GET_STAT));
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of snmp_mib
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_snmp_mib(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_SNMP_MIB *smib = &resp->params.smib;
    cyg_uint16 OID = wlan_le16_to_cpu(smib->OID);
    cyg_uint16 QueryType = wlan_le16_to_cpu(smib->QueryType);

    ENTER();

    diag_printf("SNMP_RESP: value of the OID = %x, QueryType=%x\n", OID,
           QueryType);
    diag_printf("SNMP_RESP: Buf size  = %x\n",
           wlan_le16_to_cpu(smib->BufSize));

    if (QueryType == HostCmd_ACT_GEN_GET) {
        switch (OID) {
        case FragThresh_i:
            priv->adapter->FragThsd =
                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
            diag_printf("SNMP_RESP: FragThsd =%u\n",
                   priv->adapter->FragThsd);
            break;
        case RtsThresh_i:
            priv->adapter->RTSThsd =
                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
            diag_printf("SNMP_RESP: RTSThsd =%u\n", priv->adapter->RTSThsd);
            break;
        case ShortRetryLim_i:
            priv->adapter->TxRetryCount =
                wlan_le16_to_cpu(*((PUSHORT) (smib->Value)));
            diag_printf("SNMP_RESP: TxRetryCount =%u\n",
                   priv->adapter->RTSThsd);
            break;
        default:
            break;
        }
    }

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of radio_control
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_radio_control(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    ENTER();

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of key_material
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_key_material(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_KEY_MATERIAL *pKey = &resp->params.keymaterial;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    if (pKey->Action == HostCmd_ACT_SET) {
        if ((pKey->KeyParamSet.KeyInfo & KEY_INFO_TKIP_MCAST)
            || (pKey->KeyParamSet.KeyInfo & KEY_INFO_AES_MCAST)) {
            diag_printf("Key: GTK is set\n");
            Adapter->IsGTK_SET = TRUE;
        }
    }

    memcpy((void *)Adapter->aeskey.KeyParamSet.Key, (void *)pKey->KeyParamSet.Key,
           sizeof(pKey->KeyParamSet.Key));

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of mac_address
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_mac_address(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_MAC_ADDRESS *MacAdd = &resp->params.macadd;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    memcpy(Adapter->CurrentAddr, (void *)MacAdd->MacAdd, ETH_ALEN);

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of rf_tx_power
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_rf_tx_power(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_RF_TX_POWER *rtp = &resp->params.txp;
    wlan_adapter *Adapter = priv->adapter;
    cyg_uint16 Action = wlan_le16_to_cpu(rtp->Action);

    ENTER();

    Adapter->TxPowerLevel = wlan_le16_to_cpu(rtp->CurrentLevel);

    if (Action == HostCmd_ACT_GET) {
        Adapter->MaxTxPowerLevel = rtp->MaxPower;
        Adapter->MinTxPowerLevel = rtp->MinPower;
    }

    diag_printf("Current TxPower Level = %d,Max Power=%d, Min Power=%d\n",
           Adapter->TxPowerLevel, Adapter->MaxTxPowerLevel,
           Adapter->MinTxPowerLevel);

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of rf_antenna
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_rf_antenna(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    PHostCmd_DS_802_11_RF_ANTENNA pAntenna = &resp->params.rant;
    wlan_adapter *Adapter = priv->adapter;
    cyg_uint16 Action = wlan_le16_to_cpu(pAntenna->Action);

    if (Action == HostCmd_ACT_GET_RX)
        Adapter->RxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);

    if (Action == HostCmd_ACT_GET_TX)
        Adapter->TxAntennaMode = wlan_le16_to_cpu(pAntenna->AntennaMode);

    diag_printf("RF_ANT_RESP: Action = 0x%x, Mode = 0x%04x\n",
           Action, wlan_le16_to_cpu(pAntenna->AntennaMode));

    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of multicast_address
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_mac_multicast_adr(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of rate_adapt_rateset
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_rate_adapt_rateset(wlan_private * priv,
                                   HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_RATE_ADAPT_RATESET *rates = &resp->params.rateset;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    if (rates->Action == HostCmd_ACT_GET) {
        Adapter->EnableHwAuto = rates->EnableHwAuto;
        Adapter->RateBitmap = rates->Bitmap;
    }

    LEAVE();

    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of rf_channel
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_rf_channel(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_RF_CHANNEL *rfchannel = &resp->params.rfchannel;
    wlan_adapter *Adapter = priv->adapter;
    cyg_uint16 Action = wlan_le16_to_cpu(rfchannel->Action);
    cyg_uint16 newChannel = wlan_le16_to_cpu(rfchannel->CurrentChannel);

    ENTER();

    if (Action == HostCmd_OPT_802_11_RF_CHANNEL_GET
        && Adapter->CurBssParams.channel != newChannel) {
        diag_printf("Channel Switch: %d to %d\n",
               Adapter->CurBssParams.channel, newChannel);

        /* Update the channel again */
        Adapter->CurBssParams.channel = newChannel;
    }

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of rssi
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_802_11_rssi(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_RSSI_RSP *rssirsp = &resp->params.rssirsp;
    wlan_adapter *Adapter = priv->adapter;

    /* store the non average value */
    Adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = wlan_le16_to_cpu(rssirsp->SNR);
    Adapter->NF[TYPE_BEACON][TYPE_NOAVG] =
        wlan_le16_to_cpu(rssirsp->NoiseFloor);

    Adapter->SNR[TYPE_BEACON][TYPE_AVG] = wlan_le16_to_cpu(rssirsp->AvgSNR);
    Adapter->NF[TYPE_BEACON][TYPE_AVG] =
        wlan_le16_to_cpu(rssirsp->AvgNoiseFloor);

    Adapter->RSSI[TYPE_BEACON][TYPE_NOAVG] =
        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
                 Adapter->NF[TYPE_BEACON][TYPE_NOAVG]);

    Adapter->RSSI[TYPE_BEACON][TYPE_AVG] =
        CAL_RSSI(Adapter->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
                 Adapter->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);

    diag_printf("Beacon RSSI value = 0x%x\n",
           Adapter->RSSI[TYPE_BEACON][TYPE_AVG]);

    return WLAN_STATUS_SUCCESS;
}

#ifdef	MFG_CMD_SUPPORT
/** 
 *  @brief This function handles the command response of mfg_cmd
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_mfg_cmd(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    if (Adapter->mfg_cmd_flag == 1) {
        // enough buffer for the response
        if (priv->wlan_dev.upld_len <= Adapter->mfg_cmd_len) {
            memcpy(Adapter->mfg_cmd,
                   Adapter->CurCmd->BufVirtualAddr + SDIO_HEADER_LEN, priv->wlan_dev.upld_len);//clyu SDIO_HEADER_LEN
            Adapter->mfg_cmd_resp_len = priv->wlan_dev.upld_len;
        } else {
            memset(Adapter->mfg_cmd, 0, Adapter->mfg_cmd_len);
            Adapter->mfg_cmd_resp_len = -1;
        }
        //wake_up_interruptible(&(Adapter->mfg_cmd_q));
        cyg_cond_broadcast(&Adapter->mfg_cond_q);
        Adapter->mfg_cmd_flag = 0;
    }

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}
#endif /* MFG_CMD_SUPPORT */

/** 
 *  @brief This function handles the command response of eeprom_access
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
int
wlan_ret_802_11_eeprom_access(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    wlan_adapter *Adapter = priv->adapter;
    wlan_ioctl_regrdwr *pBuf = (wlan_ioctl_regrdwr *) Adapter->pRdeeprom;
    diag_printf("eeprom read len=%x\n",
           wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
    if (pBuf->NOB < wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount)) {
        pBuf->NOB = 0;
        diag_printf("eeprom read return length is too big\n");
        return WLAN_STATUS_FAILURE;
    }
    pBuf->NOB = wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount);
    if (pBuf->NOB > 0) {

        memcpy(&pBuf->Value, (cyg_uint8 *) & resp->params.rdeeprom.Value,
               wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
        HEXDUMP("Adapter", (char *) &pBuf->Value,
                wlan_le16_to_cpu(resp->params.rdeeprom.ByteCount));
    }
    return WLAN_STATUS_SUCCESS;
}

/** 
 *  @brief This function handles the command response of get_log
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @param resp	   A pointer to HostCmd_DS_COMMAND
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
static int
wlan_ret_get_log(wlan_private * priv, HostCmd_DS_COMMAND * resp)
{
    PHostCmd_DS_802_11_GET_LOG LogMessage =
        (PHostCmd_DS_802_11_GET_LOG) & resp->params.glog;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    /* TODO Convert it to Big Endian before copy */
    memcpy((void *)&Adapter->LogMsg, (void *)LogMessage, sizeof(HostCmd_DS_802_11_GET_LOG));

    LEAVE();
    return WLAN_STATUS_SUCCESS;
}

static void
wlan_ret_802_11_IBSS_Coalesced_Status(wlan_private * priv,
                                      HostCmd_DS_COMMAND * resp)
{
    HostCmd_DS_802_11_IBSS_Status *IBSSStatusRsp;
    wlan_adapter *Adapter;
    union iwreq_data wrqu;
    cyg_uint8 nullMac[6] = { 0, 0, 0, 0, 0, 0 };

    Adapter = priv->adapter;
    IBSSStatusRsp = &(resp->params.ibssCoalescing);

    if (Adapter->CurCmd->pdata_buf)
        *(int *) Adapter->CurCmd->pdata_buf = IBSSStatusRsp->Enable;

    if (IBSSStatusRsp->Action == HostCmd_ACT_SET) {
        return;
    }

    diag_printf("New BSSID %x:%x:%x:%x:%x:%x\n",
           IBSSStatusRsp->BSSID[0],
           IBSSStatusRsp->BSSID[1],
           IBSSStatusRsp->BSSID[2],
           IBSSStatusRsp->BSSID[3],
           IBSSStatusRsp->BSSID[4], IBSSStatusRsp->BSSID[5]);

    /* if rsp has NULL BSSID, Just return.. No Action */
    if (!memcmp((void *)IBSSStatusRsp->BSSID, nullMac, MRVDRV_ETH_ADDR_LEN)) {
        diag_printf("New BSSID is NULL\n");
        return;
    }

    /* if BSSID is diff, Send evnet to Linux */
    if (memcmp(Adapter->CurBssParams.bssid,
               (void *)IBSSStatusRsp->BSSID, MRVDRV_ETH_ADDR_LEN)) {
        memcpy((void *) (Adapter->CurBssParams.bssid),
               (void *) (IBSSStatusRsp->BSSID), MRVDRV_ETH_ADDR_LEN);

        /* Beacon Interval and ATIM window */
        Adapter->CurBssParams.BSSDescriptor.BeaconPeriod =
            IBSSStatusRsp->BeaconInterval;
        Adapter->CurBssParams.BSSDescriptor.ATIMWindow =
            IBSSStatusRsp->ATIMWindow;

        memset(&wrqu, 0, sizeof(wrqu));
        memcpy(wrqu.ap_addr.sa_data, Adapter->CurBssParams.bssid, ETH_ALEN);
        wrqu.ap_addr.sa_family = ARPHRD_ETHER;

        wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
    }
}

/********************************************************
		Global Functions
********************************************************/

/** 
 *  @brief This function handles the command response
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
int
wlan_process_rx_command(wlan_private * priv)
{
    cyg_uint16 RespCmd;
    HostCmd_DS_COMMAND *resp;
    wlan_adapter *Adapter = priv->adapter;
    int ret = WLAN_STATUS_SUCCESS;
    ulong volatile flags;
    cyg_uint16 Result;

    ENTER();

    diag_printf("CMD_RESP: @ %lu\n", cyg_current_time());

    /* Now we got response from FW, cancel the command timer */
    if (Adapter->CommandTimerIsSet) {
        //CancelTimer(&Adapter->MrvDrvCommandTimer);
        cyg_alarm_disable(cmd_alarm_handle);
		//cyg_alarm_delete(cmd_alarm_handle);
        Adapter->CommandTimerIsSet = FALSE;
    }

    if (!Adapter->CurCmd) {
        diag_printf("CMD_RESP: NULL CurCmd=%p\n", Adapter->CurCmd);
        ret = WLAN_STATUS_FAILURE;
        goto done;
    }
    resp = (HostCmd_DS_COMMAND *) (Adapter->CurCmd->BufVirtualAddr);

    HEXDUMP("CMD_RESP:", Adapter->CurCmd->BufVirtualAddr,
            priv->wlan_dev.upld_len);

    RespCmd = wlan_le16_to_cpu(resp->Command);

    Result = wlan_le16_to_cpu(resp->Result);

    diag_printf("CMD_RESP: %x Result: %d Length: %d\n", RespCmd,
           Result, priv->wlan_dev.upld_len);

    if (!(RespCmd & 0x8000)) {
        diag_printf("Invalid response to command!");
        Adapter->CurCmdRetCode = WLAN_STATUS_FAILURE;
        CleanupAndInsertCmd(priv, Adapter->CurCmd);
        //spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
        OS_INT_DISABLE(flags);
        Adapter->CurCmd = NULL;
        OS_INT_RESTORE(flags);
        //spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);

        ret = WLAN_STATUS_FAILURE;
        goto done;
    }

    /* Store the response code to CurCmdRetCode. */
    Adapter->CurCmdRetCode = wlan_le16_to_cpu(resp->Result);

    if (RespCmd == HostCmd_RET_802_11_PS_MODE) {
        HostCmd_DS_802_11_PS_MODE *psmode;

        psmode = &resp->params.psmode;
        diag_printf("CMD_RESP: PS_MODE cmd reply result=%x action=0x%X\n",
               resp->Result, psmode->Action);
        psmode->Action = wlan_cpu_to_le16(psmode->Action);

        if (Result) {
            diag_printf("CMD_RESP: PS command failed- %#x \n", resp->Result);
            if (Adapter->InfrastructureMode == Wlan802_11IBSS) {
                /* 
                 * We should not re-try enter-ps command in 
                 * ad-hoc mode. It takes place in 
                 * ExecuteNextCommand().
                 */
                if (psmode->Action == HostCmd_SubCmd_Enter_PS)
                    Adapter->PSMode = Wlan802_11PowerModeCAM;
            }
        } else if (psmode->Action == HostCmd_SubCmd_Enter_PS) {
            Adapter->NeedToWakeup = FALSE;
            Adapter->PSState = PS_STATE_AWAKE;
            diag_printf("CMD_RESP: Enter_PS command response\n");
            if (Adapter->MediaConnectStatus != WlanMediaStateConnected) {
                /*
                 * When Deauth Event received before Enter_PS command
                 * response, We need to wake up the firmware.
                 */
                diag_printf("Disconnected, Going to invoke PSWakeup\n");
                PSWakeup(priv, 0);
            }
        } else if (psmode->Action == HostCmd_SubCmd_Exit_PS) {
            Adapter->NeedToWakeup = FALSE;
            Adapter->PSState = PS_STATE_FULL_POWER;
            diag_printf("CMD_RESP: Exit_PS command response\n");
        } else {
            diag_printf("CMD_RESP: PS- Action=0x%X\n", psmode->Action);
        }

        CleanupAndInsertCmd(priv, Adapter->CurCmd);
        //spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
        OS_INT_DISABLE(flags);
        Adapter->CurCmd = NULL;
        OS_INT_RESTORE(flags);
        //spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);

        ret = WLAN_STATUS_SUCCESS;
        goto done;
    }

    if (Adapter->CurCmd->CmdFlags & CMD_F_HOSTCMD) {
        /* Copy the response back to response buffer */
        memcpy(Adapter->CurCmd->pdata_buf, (void*)resp, resp->Size);

        Adapter->CurCmd->CmdFlags &= ~CMD_F_HOSTCMD;
    }

    /* If the command is not successful, cleanup and return failure */
    if ((Result != HostCmd_RESULT_OK || !(RespCmd & 0x8000))) {
        diag_printf("CMD_RESP: command reply %#x result=%#x\n",
               resp->Command, resp->Result);
        /*
         * Handling errors here
         */
        switch (RespCmd) {
        case HostCmd_RET_HW_SPEC_INFO:
            diag_printf("CMD_RESP: HW spec command Failed\n");
            break;

        }

        CleanupAndInsertCmd(priv, Adapter->CurCmd);
       // spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
       	OS_INT_DISABLE(flags);
        Adapter->CurCmd = NULL;
        OS_INT_RESTORE(flags);
        //spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);

        return WLAN_STATUS_FAILURE;
    }

	diag_printf("\n\nRespCmd = %08x\n\n", RespCmd);
    switch (RespCmd) {
    case HostCmd_RET_MAC_REG_ACCESS:
    case HostCmd_RET_BBP_REG_ACCESS:
    case HostCmd_RET_RF_REG_ACCESS:
        ret = wlan_ret_reg_access(priv, RespCmd, resp);
        break;

    case HostCmd_RET_HW_SPEC_INFO:
        ret = wlan_ret_get_hw_spec(priv, resp);
        break;

    case HostCmd_RET_802_11_BG_SCAN_QUERY:
        {
            union iwreq_data wrqu;

            ret = wlan_ret_802_11_scan(priv, resp);
            memset(&wrqu, 0, sizeof(union iwreq_data));
            wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
                                NULL);
            diag_printf("CMD_RESP: BG_SCAN result is ready!\n");
            break;
        }
    case HostCmd_RET_802_11_SCAN:
        ret = wlan_ret_802_11_scan(priv, resp);
        break;

    case HostCmd_RET_MAC_CONTROL:
        ret = wlan_ret_mac_control(priv, resp);
        break;

    case HostCmd_RET_802_11_GET_LOG:
        ret = wlan_ret_get_log(priv, resp);
        break;

    case HostCmd_RET_802_11_ASSOCIATE:
    case HostCmd_RET_802_11_REASSOCIATE:
        ret = wlan_ret_802_11_associate(priv, resp);
        break;

    case HostCmd_RET_802_11_DISASSOCIATE:
    case HostCmd_RET_802_11_DEAUTHENTICATE:
        ret = wlan_ret_802_11_disassociate(priv, resp);
        break;

    case HostCmd_RET_802_11_SET_WEP:
        ret = wlan_ret_802_11_set_wep(priv, resp);
        break;

    case HostCmd_RET_802_11_AD_HOC_START:
    case HostCmd_RET_802_11_AD_HOC_JOIN:
        ret = wlan_ret_802_11_ad_hoc(priv, resp);
        break;

    case HostCmd_RET_802_11_RESET:
        ret = wlan_ret_802_11_reset(priv, resp);
        break;

    case HostCmd_RET_802_11_AUTHENTICATE:
        ret = wlan_ret_802_11_authenticate(priv, resp);
        break;

    case HostCmd_RET_802_11_STAT:
        ret = wlan_ret_802_11_stat(priv, resp);
        break;

    case HostCmd_RET_802_11_SNMP_MIB:
        ret = wlan_ret_802_11_snmp_mib(priv, resp);
        break;

    case HostCmd_RET_802_11_RF_TX_POWER:
        ret = wlan_ret_802_11_rf_tx_power(priv, resp);
        break;

    case HostCmd_RET_802_11_RADIO_CONTROL:
        ret = wlan_ret_802_11_radio_control(priv, resp);
        break;

    case HostCmd_RET_802_11_DEEP_SLEEP:
        Adapter->IsDeepSleep = TRUE;
        break;

    case HostCmd_RET_802_11_HOST_SLEEP_CFG:
        diag_printf("CMD_RESP: Host Sleep Cfg cmd resp 0x%04X received\n",
               RespCmd);
        ret = wlan_ret_host_sleep_cfg(priv, resp);
        break;
    case HostCmd_RET_802_11_HOST_SLEEP_AWAKE_CONFIRM:
        diag_printf(
               "CMD_RESP: Host Sleep Awake Confirm cmd resp 0x%04X received\n",
               RespCmd);
        wlan_host_sleep_deactivated_event(priv); //JONO
        break;
    case HostCmd_RET_802_11_HOST_SLEEP_ACTIVATE: //JONO
      diag_printf("CMD_RESP: Host Sleep Activate cmd resp 0x%04X received\n",
               RespCmd);
        if (Adapter->HSCfg_Gap == HOST_SLEEP_CFG_GAP_FF) //JONO
            Adapter->bWakeupDevRequired = TRUE; //JONO
        wlan_host_sleep_activated_event(priv); //JONO
        break; //JONO

    case HostCmd_RET_802_11_SET_AFC:
    case HostCmd_RET_802_11_GET_AFC:
        memmove(Adapter->CurCmd->pdata_buf,
                (void *)&resp->params.afc, sizeof(HostCmd_DS_802_11_AFC));

        break;
    case HostCmd_RET_802_11_RF_ANTENNA:
        ret = wlan_ret_802_11_rf_antenna(priv, resp);
        break;

    case HostCmd_RET_MAC_MULTICAST_ADR:
        ret = wlan_ret_mac_multicast_adr(priv, resp);
        break;

    case HostCmd_RET_802_11_RATE_ADAPT_RATESET:
        ret = wlan_ret_802_11_rate_adapt_rateset(priv, resp);
        break;
    case HostCmd_RET_802_11_RF_CHANNEL:
        ret = wlan_ret_802_11_rf_channel(priv, resp);
        break;

    case HostCmd_RET_802_11_RSSI:
        ret = wlan_ret_802_11_rssi(priv, resp);
        break;

    case HostCmd_RET_802_11_MAC_ADDRESS:
        ret = wlan_ret_802_11_mac_address(priv, resp);
        break;

#ifdef MFG_CMD_SUPPORT
    case HostCmd_RET_MFG_COMMAND:
        ret = wlan_ret_mfg_cmd(priv, resp);
        break;
#endif
    case HostCmd_RET_802_11_AD_HOC_STOP:
        ret = wlan_ret_802_11_ad_hoc_stop(priv, resp);
        break;

    case HostCmd_RET_802_11_BEACON_STOP:
        break;

    case HostCmd_RET_802_11_ENABLE_RSN:
        break;
    case HostCmd_RET_802_11_KEY_MATERIAL:
        diag_printf("CMD_RESP: KEY_MATERIAL command response\n");
        ret = wlan_ret_802_11_key_material(priv, resp);
        break;

    case HostCmd_RET_802_11_EEPROM_ACCESS:
        ret = wlan_ret_802_11_eeprom_access(priv, resp);
        break;

    case HostCmd_RET_802_11D_DOMAIN_INFO:
        ret = wlan_ret_802_11d_domain_info(priv, resp);
        break;

    case HostCmd_RET_802_11_SLEEP_PARAMS:
        ret = wlan_ret_802_11_sleep_params(priv, resp);
        break;
    case HostCmd_RET_802_11_BCA_CONFIG_TIMESHARE:
        ret = wlan_ret_802_11_bca_timeshare(priv, resp);
        break;
    case HostCmd_RET_802_11_INACTIVITY_TIMEOUT:
        *((cyg_uint16 *) Adapter->CurCmd->pdata_buf) =
            wlan_le16_to_cpu(resp->params.inactivity_timeout.Timeout);
        break;
    case HostCmd_RET_802_11_BG_SCAN_CONFIG:
        diag_printf("CMD_RESP: BG_CONFIG CMD response\n");
        break;

    case HostCmd_RET_802_11_FW_WAKEUP_METHOD:
        diag_printf("CMD_RESP: FW_WAKEUP_METHOD CMD response\n");
        ret = wlan_ret_fw_wakeup_method(priv, resp);
        break;

    case HostCmd_RET_802_11_SLEEP_PERIOD:
        ret = wlan_ret_802_11_sleep_period(priv, resp);
        break;
    case HostCmd_RET_WMM_ACK_POLICY:
        ret = wlan_cmdresp_wmm_ack_policy(priv, resp);
        break;
    case HostCmd_RET_WMM_GET_STATUS:
        ret = wlan_cmdresp_wmm_get_status(priv, resp);
        break;
    case HostCmd_RET_WMM_ADDTS_REQ:
        ret = wlan_cmdresp_wmm_addts_req(priv, resp);
        break;
    case HostCmd_RET_WMM_DELTS_REQ:
        ret = wlan_cmdresp_wmm_delts_req(priv, resp);
        break;
    case HostCmd_RET_WMM_QUEUE_CONFIG:
        ret = wlan_cmdresp_wmm_queue_config(priv, resp);
        break;
    case HostCmd_RET_WMM_QUEUE_STATS:
        ret = wlan_cmdresp_wmm_queue_stats(priv, resp);
        break;
    case HostCmd_RET_802_11_TPC_CFG:
        memmove(Adapter->CurCmd->pdata_buf,
                (void *)&resp->params.tpccfg, sizeof(HostCmd_DS_802_11_TPC_CFG));
        break;
    case HostCmd_RET_802_11_LED_GPIO_CTRL:
        memmove(Adapter->CurCmd->pdata_buf,
                (void*)&resp->params.ledgpio, sizeof(HostCmd_DS_802_11_LED_CTRL));
        break;
    case HostCmd_RET_802_11_PWR_CFG:
        memmove(Adapter->CurCmd->pdata_buf,
                (void*)&resp->params.pwrcfg, sizeof(HostCmd_DS_802_11_PWR_CFG));

        break;

    case HostCmd_RET_GET_TSF:
        memcpy(priv->adapter->CurCmd->pdata_buf,
               (void*)&resp->params.gettsf.TsfValue, sizeof(cyg_uint64));
        break;
    case HostCmd_RTE_802_11_TX_RATE_QUERY:
        priv->adapter->TxRate = resp->params.txrate.TxRate;
        break;
    case HostCmd_RET_802_11_IBSS_COALESCING_STATUS:
        wlan_ret_802_11_IBSS_Coalesced_Status(priv, resp);
        break;

    default:
        diag_printf("CMD_RESP: Unknown command response %#x\n",
               resp->Command);
        break;
    }

    if (Adapter->CurCmd) {
        /* Clean up and Put current command back to CmdFreeQ */
        CleanupAndInsertCmd(priv, Adapter->CurCmd);
        //spin_lock_irqsave(&Adapter->QueueSpinLock, flags);
        OS_INT_DISABLE(flags);
        Adapter->CurCmd = NULL;
        OS_INT_RESTORE(flags);
        //spin_unlock_irqrestore(&Adapter->QueueSpinLock, flags);
    }

  done:
    LEAVE();
    return ret;
}

#if WIRELESS_EXT >= 18
/** 
 *  @brief This function sends mic error event to application.
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @para event    MIC ERROR EVENT. 
 *  @return 	   n/a
 */
void
send_mic_error_event(wlan_private * priv, cyg_uint32 event)
{
    union iwreq_data iwrq;
    struct iw_michaelmicfailure mic;

    ENTER();

    memset(&iwrq, 0, sizeof(iwrq));
    memset(&mic, 0, sizeof(mic));
    if (event == MACREG_INT_CODE_MIC_ERR_UNICAST) {
        mic.flags = IW_MICFAILURE_PAIRWISE;
    } else {
        mic.flags = IW_MICFAILURE_GROUP;
    }

    iwrq.data.pointer = (void*)&mic;
    iwrq.data.length = sizeof(mic);

    wireless_send_event(priv->wlan_dev.netdev, IWEVMICHAELMICFAILURE, &iwrq,
                        (char *) & mic);

    LEAVE();
    return;
}
#endif

/** 
 *  @brief This function handles events generated by firmware
 *  
 *  @param priv    A pointer to wlan_private structure
 *  @return 	   WLAN_STATUS_SUCCESS or WLAN_STATUS_FAILURE
 */
int
wlan_process_event(wlan_private *priv)
{
    int ret = WLAN_STATUS_SUCCESS;
    wlan_adapter *Adapter = priv->adapter;

    ENTER();

    diag_printf("EVENT Cause %x\n", Adapter->EventCause);

    switch (Adapter->EventCause >> SBI_EVENT_CAUSE_SHIFT) {
    case MACREG_INT_CODE_LINK_SENSED:
        //os_carrier_on(priv);
       // os_start_queue(priv);
        diag_printf("EVENT: MACREG_INT_CODE_LINK_SENSED\n");
        break;

    case MACREG_INT_CODE_DEAUTHENTICATED:
        diag_printf("EVENT: Deauthenticated\n");
        HandleDisconnectEvent(priv);
        break;

    case MACREG_INT_CODE_DISASSOCIATED:
        diag_printf("EVENT: Disassociated\n");
        HandleDisconnectEvent(priv);
        break;

    case MACREG_INT_CODE_LINK_LOSE_NO_SCAN:
        diag_printf("EVENT: Link lost\n");
        HandleDisconnectEvent(priv);
        break;

    case MACREG_INT_CODE_PS_SLEEP:
        diag_printf("EVENT: SLEEP\n");
        diag_printf("_");

        /* handle unexpected PS SLEEP event */
        if (Adapter->PSState == PS_STATE_FULL_POWER) {
            diag_printf("EVENT: In FULL POWER mode - ignore PS SLEEP\n");
            break;
        }
        Adapter->PSState = PS_STATE_PRE_SLEEP;

        PSConfirmSleep(priv, (cyg_uint16) Adapter->PSMode);

        break;

    case MACREG_INT_CODE_PS_AWAKE:
        diag_printf("EVENT: AWAKE \n");
        diag_printf("|");

        /* handle unexpected PS AWAKE event */
        if (Adapter->PSState == PS_STATE_FULL_POWER) {
            diag_printf("EVENT: In FULL POWER mode - ignore PS AWAKE\n");
            break;
        }

        Adapter->TxLockFlag = FALSE;
        if (TRUE == CheckLastPacketIndication(priv)) {
            if (Adapter->gen_null_pkg) {
                SendNullPacket(priv, MRVDRV_TxPD_POWER_MGMT_NULL_PACKET |
                               MRVDRV_TxPD_POWER_MGMT_LAST_PACKET);
                Adapter->TxLockFlag = TRUE;
            }
        }

        Adapter->PSState = PS_STATE_AWAKE;
	
        if (Adapter->NeedToWakeup == TRUE)
        {
            /*
             * wait for the command processing to finish
             * before resuming sending 
             * Adapter->NeedToWakeup will be set to FALSE 
             * in PSWakup()
             */
            diag_printf("Waking up...%d\n", Adapter->PSState);
             Adapter->PSState = PS_STATE_AWAKE;
            PSWakeup(priv, 0);
        }
       
        break;

    case MACREG_INT_CODE_DEEP_SLEEP_AWAKE:
        sbi_reset_deepsleep_wakeup(priv);
        diag_printf("EVENT: DEEP SLEEP AWAKE Event!\n");

        Adapter->IsDeepSleep = FALSE;
       // os_carrier_on(priv);
       // os_start_queue(priv);

        //wake_up_interruptible(&Adapter->ds_awake_q);
        cyg_cond_broadcast(&Adapter->ds_cond_q);
        break;

    case MACREG_INT_CODE_HOST_SLEEP_AWAKE:
        Adapter->bWakeupDevRequired = FALSE;
        Adapter->WakeupTries = 0;
        sbi_reset_deepsleep_wakeup(priv);
        diag_printf("EVENT: HOST SLEEP AWAKE Event!\n");

        /*
         * in BG SCAN mode w/ deep sleep, WAKE UP event
         * will be sent directly, no Deep Sleep Awake will
         * be sent. so we need to wakeup ds_awake_q here
         */
        //wake_up_interruptible(&Adapter->ds_awake_q);
        cyg_cond_broadcast(&Adapter->ds_cond_q);
        ret = PrepareAndSendCommand(priv,
                                    HostCmd_CMD_802_11_HOST_SLEEP_AWAKE_CONFIRM,
                                    0, 0, 0, NULL);
        break;

    case MACREG_INT_CODE_MIC_ERR_UNICAST:
        diag_printf("EVENT: UNICAST MIC ERROR\n");
#if WIRELESS_EXT >= 18
        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_UNICAST);
#else
        send_iwevcustom_event(priv, (cyg_int8 *)CUS_EVT_MLME_MIC_ERR_UNI);
#endif
        break;

    case MACREG_INT_CODE_MIC_ERR_MULTICAST:
        diag_printf("EVENT: MULTICAST MIC ERROR\n");
#if WIRELESS_EXT >= 18
        send_mic_error_event(priv, MACREG_INT_CODE_MIC_ERR_MULTICAST);
#else
        send_iwevcustom_event(priv, (cyg_int8 *)CUS_EVT_MLME_MIC_ERR_MUL);
#endif
        break;
    case MACREG_INT_CODE_MIB_CHANGED:
    case MACREG_INT_CODE_INIT_DONE:
        break;

    case MACREG_INT_CODE_ADHOC_BCN_LOST:
        /* Free Tx and Rx packets */
        //os_free_tx_packet(priv);
        //wlan_send_rxskbQ(priv);

        /* report disconnect to upper layer */
        //os_stop_queue(priv);
       // os_carrier_off(priv);
        diag_printf("EVENT: HWAC - ADHOC BCN LOST\n");
        break;
    case MACREG_INT_CODE_BG_SCAN_REPORT:
        diag_printf("EVENT: Background SCAN Report\n");
        ret = sendBgScanQueryCmd(priv);
        break;
    case MACREG_INT_CODE_WMM_STATUS_CHANGE:
        diag_printf("EVENT: WMM status changed\n");
        ret = sendWMMStatusChangeCmd(priv);
        break;

    case MACREG_INT_CODE_RSSI_LOW:
        diag_printf("EVENT: RSSI_LOW\n");
        send_iwevcustom_event(priv, (cyg_int8*)CUS_EVT_RSSI_LOW);
        break;
    case MACREG_INT_CODE_SNR_LOW:
        diag_printf("EVENT: SNR_LOW\n");
        send_iwevcustom_event(priv, (cyg_int8*)CUS_EVT_SNR_LOW);
        break;
    case MACREG_INT_CODE_MAX_FAIL:
        diag_printf("EVENT: MAX_FAIL\n");
        send_iwevcustom_event(priv, (cyg_int8*)CUS_EVT_MAX_FAIL);
        break;
    case MACREG_INT_CODE_RSSI_HIGH:
        diag_printf("EVENT: RSSI_HIGH\n");
        send_iwevcustom_event(priv, (cyg_int8*)CUS_EVT_RSSI_HIGH);
        break;
    case MACREG_INT_CODE_SNR_HIGH:
        diag_printf("EVENT: SNR_HIGH\n");
        send_iwevcustom_event(priv, (cyg_int8*)CUS_EVT_SNR_HIGH);
        break;
    case MACREG_INT_CODE_IBSS_COALESCED:
        diag_printf("EVENT IBSS Event\n");
        ret = sendADHOCBSSIDQuery(priv);
        break;

    default:
        diag_printf("EVENT: unknown event id: %#x\n",
               Adapter->EventCause >> SBI_EVENT_CAUSE_SHIFT);
        break;
    }

    if ((Adapter->EventCause >> SBI_EVENT_CAUSE_SHIFT) != MACREG_INT_CODE_PS_SLEEP)
    	wifiSetHostSleepFlag(FALSE);

    Adapter->EventCause = 0;
    LEAVE();
    return ret;
}
